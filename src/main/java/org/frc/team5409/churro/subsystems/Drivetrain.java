package org.frc.team5409.churro.subsystems;

import edu.wpi.first.wpilibj.DigitalInput;
import edu.wpi.first.wpilibj.Encoder;
<<<<<<< Updated upstream
import edu.wpi.first.wpilibj2.command.Subsystem;
=======

import com.ctre.phoenix.motorcontrol.ControlMode;
import com.ctre.phoenix.motorcontrol.can.VictorSPX;

import org.frc.team5409.churro.commands.*;

>>>>>>> Stashed changes

// BEGIN AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=IMPORTS
import edu.wpi.first.wpilibj.drive.DifferentialDrive;
// END AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=IMPORTS

public class Drivetrain implements Subsystem {
//===================================================================
//ROBOT BUILDER

    // BEGIN AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=DECLARATIONS
    private VictorSPX mo_leftDrive_C20;
    private VictorSPX mo_leftDrive_C21;
    private VictorSPX mo_rightDrive_C20;
    private VictorSPX mo_rightDrive_C21;
    private DifferentialDrive    m_differentialDrive;
    // END AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=DECLARATIONS

    // BEGIN AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=CONSTANTS
    public static final double c_Drivetrain_Wheel_Diamater_in = 6;
    public static final double c_Drivetrain_Gear_Ratio = 10.71;
    // END AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=CONSTANTS

//===================================================================
//PRE-CALCULATED CONSTANTS

    public static final double c_Distance_Per_Pulse = 
        (Math.PI * c_Drivetrain_Wheel_Diamater_in) / (c_Drivetrain_Gear_Ratio*4);

//===================================================================
//MEMBER VARIABLES

    private double m_wheel_velocity_R = 0;
    private double m_wheel_velocity_L = 0;

    private Object m_this_mutex = new Object();
//===================================================================

    public Drivetrain() {
        mo_leftDrive_C20 = new VictorSPX(0);

<<<<<<< Updated upstream
        //setDefaultCommand(new Drive());
    }

    @Override
    public void periodic() {
        final double velocity_L;
        final double velocity_R;

        synchronized(m_this_mutex) {
            velocity_L = m_wheel_velocity_L;
            velocity_R = m_wheel_velocity_R;
        }
=======
        mo_leftDrive_C21 = new VictorSPX(0);
            mo_leftDrive_C21.follow(mo_leftDrive_C20);

        mo_rightDrive_C20 = new VictorSPX(0);
>>>>>>> Stashed changes

        mo_rightDrive_C21 = new VictorSPX(0);
            mo_rightDrive_C21.follow(mo_rightDrive_C20);
            
        setDefaultCommand(new Drive());
    }

    // BEGIN AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=CMDPIDGETTERS
    // END AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=CMDPIDGETTERS

    public void arcadeDrive(double speed_X, double rotation_Z) {
        double left_motor_output;
        double right_motor_output;

        limit(speed_X);
        limit(rotation_Z);

        //Might have to flip these for some reason
        speed_X = Math.copySign(speed_X * speed_X, speed_X);
        rotation_Z = Math.copySign(rotation_Z * rotation_Z, rotation_Z);

        final double maxInput = Math.copySign(
            Math.max(Math.abs(speed_X), Math.abs(rotation_Z)), speed_X);
    
        if (speed_X >= 0.0) {
            if (rotation_Z >= 0.0) {
                left_motor_output = maxInput;
                right_motor_output = speed_X - rotation_Z;
            } else {
                left_motor_output = speed_X + rotation_Z;
                right_motor_output = maxInput;
            }
        } else {
            if (rotation_Z >= 0.0) {
                left_motor_output = speed_X + rotation_Z;
                right_motor_output = maxInput;
            } else {
                left_motor_output = maxInput;
                right_motor_output = speed_X - rotation_Z;
            }
        }   
    
        synchronized(m_this_mutex) {
            mo_leftDrive_C20.set(ControlMode.PercentOutput, left_motor_output);
            mo_rightDrive_C20.set(ControlMode.PercentOutput, -right_motor_output);
        }
    }

    public void tankDrive(double speed_L, double speed_R) {
        synchronized(m_this_mutex) {
            m_wheel_velocity_L = speed_L;
            m_wheel_velocity_R = speed_R;
        }
    }

    public void reset() {
        synchronized(m_this_mutex) {
            m_wheel_velocity_L = 0;
            m_wheel_velocity_R = 0;
        }
    }

    private double limit(double value) {
        if (value > 1)
            return 1;
        else if (value < 0)
            return 0;
        return value;
    }
}

